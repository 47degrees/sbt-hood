// When the user clicks on the search box, we want to toggle the search dropdown
function displayToggleSearch(e) {
  e.preventDefault();
  e.stopPropagation();

  closeDropdownSearch(e);
  
  if (idx === null) {
    console.log("Building search index...");
    prepareIdxAndDocMap();
    console.log("Search index built.");
  }
  const dropdown = document.querySelector("#search-dropdown-content");
  if (dropdown) {
    if (!dropdown.classList.contains("show")) {
      dropdown.classList.add("show");
    }
    document.addEventListener("click", closeDropdownSearch);
    document.addEventListener("keydown", searchOnKeyDown);
    document.addEventListener("keyup", searchOnKeyUp);
  }
}

//We want to prepare the index only after clicking the search bar
var idx = null
const docMap = new Map()

function prepareIdxAndDocMap() {
  const docs = [    
    {
      "title": "GitHub integration",
      "url": "/sbt-hood/github-integration/",
      "content": "GitHub integration sbt-hood can also output comparison results to a GitHub pull request as comments, as well as setting mergeability states. This allows you to set up the plugin within your CI pipelines and avoid merging code that decreases your performance under the thresholds youâ€™ve specified to the plugin. In order to allow sbt-hood to communicate with GitHub youâ€™ll need to set these additional settings: token: GitHub access token. It can be generated by browsing to Developer settings &gt; Personal access tokens within your user settings. repositoryOwner: owner of the repository where the plugin will post updates. repositoryName: name of the repository where the plugin will post updates. pullRequestNumber: pull request number where the plugin will post updates. targetUrl: optional URL to the CI job, allowing GitHub to show a link to your CI job besides the mergeability status (i.e.: TRAVIS_JOB_WEB_URL under TravisCI). shouldBlockMerge: if set to true, sbt-hood will ask GitHub to block the current PR in case a benchmark has produced errors. Defaults to true. Once these are set up, you can configure your CI scripts to call the following sbt-hood command: compareBenchmarksCI This command runs the previously described compareBenchmarks command (thus showing the comparison results in your CI job logs), and later sends a request to GitHub API to create a state for your pull request. Any comparison resulting in an error for any of your benchmarks will create an erroneous state in your pull request, thus disallowing mergeability until these are taken care of. By fine tuning the different settings of the plugin within your CI pipelines you can make sure that your applications stay performant during every code iteration. Uploading benchmark reports to GitHub In addition to controlling the state of your pull requests, sbt-hood provides an additional task that allows uploading benchmark report files (generated by compareBenchmarks and compareBenchmarksCI, provided that outputToFile is set to true). To allow sbt-hood to upload your reports, the following settings are available (take into account that the previously described GitHub settings are also required for uploads to work): benchmarkFiles: list of files to be uploaded. By default it contains an empty list (in this case, uploading to GitHub will fail). uploadDirectory: target path in your repository to upload the benchmark report files. By default itâ€™s set to benchmarks. commitMessage: each time benchmark reports are uploaded, a new commit will be push to your repository. branch: target branch in your repository to upload the benchmark report files. By default itâ€™s set to master. Once configured you can set up your CI to upload your report files by calling the following command: uploadBenchmarks By keeping these reports in your repository you can track the performance of key aspects of your code as it continues to evolve."
    } ,    
    {
      "title": "Getting Started",
      "url": "/sbt-hood/",
      "content": "Getting started Benchmark comparisons sbt-hood is able to perform comparisons based on JMH benchmarks. Providing CSV benchmarks files for both the current state of your code and any new changes you want to introduce, sbt-hood will make sure your project performs within your expected thresholds. It can work in a standalone basis or, more interestingly, within your CI pipelines. This allows automated comparisons to be performed and, should your performance variables get lower than expected, block a GitHub pull request to be merged. Standalone use In order to use sbt-hood you simply have to specify what benchmark files do you want to compare, (and the name of the important columns if your benchmark is in CSV format) through the following sbt variables: previousBenchmarkPath: path to the previous JMH benchmark in CSV/Json format. By default: {project_root}/master.csv. currentBenchmarkPath: path to the current JMH benchmark in CSV/Json format. By default: {project_root}/current.csv. keyColumnName: column name to distinguish each benchmark on the comparison. By default: Benchmark. include: regular expression to include only the benchmarks with a matching key. Optional. exclude: regular expression to exclude the benchmarks with a matching key. Optional. compareColumnName: column name of the column to compare (values must be Double). By default: Score. thresholdColumnName: column name to get the threshold per benchmark. By default: Score Error (99.9%). modeColumnName: column name to get the benchmark mode. By default: Mode. unitsColumnName: column name to get the benchmark mode. By default: Unit. generalThreshold: optional common threshold to all benchmarks overriding the value coming from thresholdColumnName. benchmarkThreshold: optional map with a custom threshold per benchmark key overriding the value coming from thresholdColumnName or generalThreshold. outputToFile: set to true saves the comparison results in a separate file in addition to the console report. By default this setting is disabled. outputPath: path to the comparison report to be generated. By default: {project_root}/comparison.md. outputFormat: file format for the comparison report. MD and JSON are supported. By default: MD. As you can see all these variables have default values or are optional so youâ€™ll just need to adapt some of these if your benchmark files are in CSV format and contain different column names. Once set up, you only need to run a benchmark comparison through the following command: compareBenchmarks If no errors are found, youâ€™ll see the comparisons being output in the sbt console. i.e.: # âœ” test.decoding (Threshold: 3.0) |Benchmark|Value| |---------|-----| |previous.json|5.0| |current_better.json|6.0| # âœ” test.parsing (Threshold: 3.0) |Benchmark|Value| |---------|-----| |previous.json|6.0| |current_better.json|7.0| For each benchmark (set by the value found under the specified keyColumnName variable) youâ€™ll see a table comparing the values of both files. Results can be of three types (visible by the icon that shows in each table): Success (âœ”): the current benchmark is better than the previous one. Warning (âš ): the current benchmark is worse than the previous one, but within the specified threshold. Error (ðŸ”´): the current benchmark is worse than the previous one, and outside the specified threshold."
    } ,        
  ];

  idx = lunr(function () {
    this.ref("title");
    this.field("content");

    docs.forEach(function (doc) {
      this.add(doc);
    }, this);
  });

  docs.forEach(function (doc) {
    docMap.set(doc.title, doc.url);
  });
}

// The onkeypress handler for search functionality
function searchOnKeyDown(e) {
  const keyCode = e.keyCode;
  const parent = e.target.parentElement;
  const isSearchBar = e.target.id === "search-bar";
  const isSearchResult = parent ? parent.id.startsWith("result-") : false;
  const isSearchBarOrResult = isSearchBar || isSearchResult;

  if (keyCode === 40 && isSearchBarOrResult) {
    // On 'down', try to navigate down the search results
    e.preventDefault();
    e.stopPropagation();
    selectDown(e);
  } else if (keyCode === 38 && isSearchBarOrResult) {
    // On 'up', try to navigate up the search results
    e.preventDefault();
    e.stopPropagation();
    selectUp(e);
  } else if (keyCode === 27 && isSearchBarOrResult) {
    // On 'ESC', close the search dropdown
    e.preventDefault();
    e.stopPropagation();
    closeDropdownSearch(e);
  }
}

// Search is only done on key-up so that the search terms are properly propagated
function searchOnKeyUp(e) {
  // Filter out up, down, esc keys
  const keyCode = e.keyCode;
  const cannotBe = [40, 38, 27];
  const isSearchBar = e.target.id === "search-bar";
  const keyIsNotWrong = !cannotBe.includes(keyCode);
  if (isSearchBar && keyIsNotWrong) {
    // Try to run a search
    runSearch(e);
  }
}

// Move the cursor up the search list
function selectUp(e) {
  if (e.target.parentElement.id.startsWith("result-")) {
    const index = parseInt(e.target.parentElement.id.substring(7));
    if (!isNaN(index) && (index > 0)) {
      const nextIndexStr = "result-" + (index - 1);
      const querySel = "li[id$='" + nextIndexStr + "'";
      const nextResult = document.querySelector(querySel);
      if (nextResult) {
        nextResult.firstChild.focus();
      }
    }
  }
}

// Move the cursor down the search list
function selectDown(e) {
  if (e.target.id === "search-bar") {
    const firstResult = document.querySelector("li[id$='result-0']");
    if (firstResult) {
      firstResult.firstChild.focus();
    }
  } else if (e.target.parentElement.id.startsWith("result-")) {
    const index = parseInt(e.target.parentElement.id.substring(7));
    if (!isNaN(index)) {
      const nextIndexStr = "result-" + (index + 1);
      const querySel = "li[id$='" + nextIndexStr + "'";
      const nextResult = document.querySelector(querySel);
      if (nextResult) {
        nextResult.firstChild.focus();
      }
    }
  }
}

// Search for whatever the user has typed so far
function runSearch(e) {
  if (e.target.value === "") {
    // On empty string, remove all search results
    // Otherwise this may show all results as everything is a "match"
    applySearchResults([]);
  } else {
    const tokens = e.target.value.split(" ");
    const moddedTokens = tokens.map(function (token) {
      // "*" + token + "*"
      return token;
    })
    const searchTerm = moddedTokens.join(" ");
    const searchResults = idx.search(searchTerm);
    const mapResults = searchResults.map(function (result) {
      const resultUrl = docMap.get(result.ref);
      return { name: result.ref, url: resultUrl };
    })

    applySearchResults(mapResults);
  }

}

// After a search, modify the search dropdown to contain the search results
function applySearchResults(results) {
  const dropdown = document.querySelector("div[id$='search-dropdown'] > .dropdown-content.show");
  if (dropdown) {
    //Remove each child
    while (dropdown.firstChild) {
      dropdown.removeChild(dropdown.firstChild);
    }

    //Add each result as an element in the list
    results.forEach(function (result, i) {
      const elem = document.createElement("li");
      elem.setAttribute("class", "dropdown-item");
      elem.setAttribute("id", "result-" + i);

      const elemLink = document.createElement("a");
      elemLink.setAttribute("title", result.name);
      elemLink.setAttribute("href", result.url);
      elemLink.setAttribute("class", "dropdown-item-link");

      const elemLinkText = document.createElement("span");
      elemLinkText.setAttribute("class", "dropdown-item-link-text");
      elemLinkText.innerHTML = result.name;

      elemLink.appendChild(elemLinkText);
      elem.appendChild(elemLink);
      dropdown.appendChild(elem);
    });
  }
}

// Close the dropdown if the user clicks (only) outside of it
function closeDropdownSearch(e) {
  // Check if where we're clicking is the search dropdown
  if (e.target.id !== "search-bar") {
    const dropdown = document.querySelector("div[id$='search-dropdown'] > .dropdown-content.show");
    if (dropdown) {
      dropdown.classList.remove("show");
      document.documentElement.removeEventListener("click", closeDropdownSearch);
    }
  }
}
